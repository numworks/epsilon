/* Normally, Flex will call yywrap when reaching an end-of-file. We don't want
 * to deal with files anyway, so let's just disable this. */
%option noyywrap

/* We're using the bison-bridge option because the bison parser is reentrant,
 * as specified by the "pure-parser" option. Using the bison-bridge option
 * prevents Flex from using global variables such as yylval. Instead, those
 * become local pointers that are passed by Bison to Flex.
 * In practice, when using bison-bridge, you shall simply use yylval as a
 * pointer.
 */
%option bison-bridge

/* Normally, on each new input file the scanner calls isatty() in an attempt to
 * determine whether the scanner's input source is interactive and thus should
 * be read a character at a time.
 * We obviously do *not* provide isatty(), and we know we're never going to use
 * an interactive input source. */
%option never-interactive

%{
/* Flex generate a lexer, a function that outputs tokens.
 * Those tokens (and the optional value that they can be attached) are defined
 * in the Bison grammar. To use those token definitions, we need to include the
 * header generated by Bison.
 * Also, since some tokens can have an "Expression" value attached, we'll
 * need "Expression" to be defined before including that header.
 * We could use the '%code requires{}' directive to make sure that Expression is
 * well defined in the parser header, but this directive only comes in bison 3,
 * which is not installed by default on MacOS, we thus made the choice to prefer
 * compatibility with MacOS's default version (2.3) instead of using the code
 * requires feature. */
#include <cmath>

/* YYSTYPE has to be defined in expression_parser.y, expression.cpp and here
 * because the genereated code is included in expression_parser.cpp, not .hpp
 * so we cannot use expression_parser.hpp here. We use an additional header
 * which only define YYSTYPE. This should be discarded with Bison 3. */
#include "expression_lexer_parser.h"

#include "expression_parser.hpp"
using namespace Poincare;

/* Flex has provision for reading files. We'll never use this, so we're defining
 * YY_INPUT which effectively disables taking input from a file. */
#define YY_INPUT

/* Flex can print to stdout what token it matches by calling the ECHO function.
 * We don't want that feature : we don't even have printf ! */
#define ECHO

/* This defines the size of the flex buffer size.
 * By default this buffer is of 16k, but we don't have the luxury to use so much
 * memory on a microcontroller.
 * The choice of 256 Bytes is the size of the input buffer given to flex in the
 * current implementation (the app takes a maximum of 256).
 */
#undef YY_BUF_SIZE
#define YY_BUF_SIZE 256

#define fprintf(...) ((void)0)
#define exit(...) abort()

%}

%%

 /* If two patterns can match the same input, flex resolves the ambiguity:
  * - By matching the longest possible string
  * - In a tie, by using the pattern that appears first
  *
  * Also note that yytext is guaranteed to be null-terminated when the token is
  * being built, (i.e. when flex calls our code snippet), but this is achieved
  * by flex temporarily swapping the last character. Afterwards the pointer is
  * still valid but the string isn't null-terminated anymore.
  */
  /* We designed our own extended-ASCII to include required symbols in less
   * than 255 glyphs. The file ion/include/ion/charset.h lists all added
   * non-ASCII symbols with their char associated. For example, the char \x89
   * refered to Pi symbols. This artefact leads to the following lexer rules
   * starting with \x. */

(([0-9]*[.]?[0-9]+)|([0-9]+[.]?[0-9]*))(\x8d\-?[0-9]+)? { *yylval = Poincare::Number::ParseDigits(yytext, yyleng); return DIGITS; }
[A-Za-z] { *yylval = Poincare::Symbol(yytext[0]); return SYMBOL; }
M[0-9] { *yylval = Poincare::Symbol(Symbol::matrixSymbol(yytext[1])); return SYMBOL; }
u\(n\) { *yylval = Poincare::Symbol(Symbol::SpecialSymbols::un); return SYMBOL; }
u\(n\+1\) { *yylval = Poincare::Symbol(Symbol::SpecialSymbols::un1); return SYMBOL; }
v\(n\) { *yylval = Poincare::Symbol(Symbol::SpecialSymbols::vn); return SYMBOL; }
v\(n\+1\) { *yylval = Poincare::Symbol(Symbol::SpecialSymbols::vn1); return SYMBOL; }
u\_\{n\} { *yylval = Poincare::Symbol(Symbol::SpecialSymbols::un); return SYMBOL; }
u\_\{n\+1\} { *yylval = Poincare::Symbol(Symbol::SpecialSymbols::un1); return SYMBOL; }
v\_\{n\} { *yylval = Poincare::Symbol(Symbol::SpecialSymbols::vn); return SYMBOL; }
v\_\{n\+1\} { *yylval = Poincare::Symbol(Symbol::SpecialSymbols::vn1); return SYMBOL; }
V1 { *yylval = Poincare::Symbol(Symbol::SpecialSymbols::V1); return SYMBOL; }
N1 { *yylval = Poincare::Symbol(Symbol::SpecialSymbols::N1); return SYMBOL; }
V2 { *yylval = Poincare::Symbol(Symbol::SpecialSymbols::V2); return SYMBOL; }
N2 { *yylval = Poincare::Symbol(Symbol::SpecialSymbols::N2); return SYMBOL; }
V3 { *yylval = Poincare::Symbol(Symbol::SpecialSymbols::V3); return SYMBOL; }
N3 { *yylval = Poincare::Symbol(Symbol::SpecialSymbols::N3); return SYMBOL; }
X1 { *yylval = Poincare::Symbol(Symbol::SpecialSymbols::X1); return SYMBOL; }
Y1 { *yylval = Poincare::Symbol(Symbol::SpecialSymbols::Y1); return SYMBOL; }
X2 { *yylval = Poincare::Symbol(Symbol::SpecialSymbols::X2); return SYMBOL; }
Y2 { *yylval = Poincare::Symbol(Symbol::SpecialSymbols::Y2); return SYMBOL; }
X3 { *yylval = Poincare::Symbol(Symbol::SpecialSymbols::X3); return SYMBOL; }
Y3 { *yylval = Poincare::Symbol(Symbol::SpecialSymbols::Y3); return SYMBOL; }
acos { *yylval = ArcCosine(); return FUNCTION; }
acosh { *yylval = HyperbolicArcCosine(); return FUNCTION; }
abs { *yylval = AbsoluteValue(); return FUNCTION; }
ans { *yylval = Poincare::Symbol(Symbol::SpecialSymbols::Ans); return SYMBOL; }
arg { *yylval = ComplexArgument(); return FUNCTION; }
asin { *yylval = ArcSine(); return FUNCTION; }
asinh { *yylval = HyperbolicArcSine(); return FUNCTION; }
atan { *yylval = ArcTangent(); return FUNCTION; }
atanh { *yylval = HyperbolicArcTangent(); return FUNCTION; }
binomial { *yylval = BinomialCoefficient(); return FUNCTION; }
ceil { *yylval = Ceiling(); return FUNCTION; }
confidence { *yylval = ConfidenceInterval(); return FUNCTION; }
diff { *yylval = Derivative(); return FUNCTION; }
dim { *yylval = MatrixDimension(); return FUNCTION; }
conj { *yylval = Conjugate(); return FUNCTION; }
det { *yylval = Determinant(); return FUNCTION; }
cos { *yylval = Cosine(); return FUNCTION; }
cosh { *yylval = HyperbolicCosine(); return FUNCTION; }
factor { *yylval = Factor(); return FUNCTION; }
floor { *yylval = Floor(); return FUNCTION; }
frac { *yylval = FracPart(); return FUNCTION; }
gcd { *yylval = GreatCommonDivisor(); return FUNCTION; }
im { *yylval = ImaginaryPart(); return FUNCTION; }
int { *yylval = Integral(); return FUNCTION; }
inverse { *yylval = MatrixInverse(); return FUNCTION; }
lcm { *yylval = LeastCommonMultiple(); return FUNCTION; }
ln { *yylval = NaperianLogarithm(); return FUNCTION; }
log { return LOGFUNCTION; }
permute { *yylval = PermuteCoefficient(); return FUNCTION; }
prediction95 { *yylval = PredictionInterval(); return FUNCTION; }
prediction { *yylval = SimplePredictionInterval(); return FUNCTION; }
product { *yylval = Product(); return FUNCTION; }
quo { *yylval = DivisionQuotient(); return FUNCTION; }
random { *yylval = Random(); return FUNCTION; }
randint { *yylval = Randint(); return FUNCTION; }
re { *yylval = RealPart(); return FUNCTION; }
rem { *yylval = DivisionRemainder(); return FUNCTION; }
root { *yylval = NthRoot(); return FUNCTION; }
round { *yylval = Round(); return FUNCTION; }
sin { *yylval = Sine(); return FUNCTION; }
sinh { *yylval = HyperbolicSine(); return FUNCTION; }
sum { *yylval = Sum(); return FUNCTION; }
tan { *yylval = Tangent(); return FUNCTION; }
tanh { *yylval = HyperbolicTangent(); return FUNCTION; }
trace { *yylval = MatrixTrace(); return FUNCTION; }
transpose { *yylval = MatrixTranspose(); return FUNCTION; }
undef { *yylval = Undefined(); return TERM; }
inf { *yylval = Infinity(false); return TERM; }
\x8a { *yylval = Poincare::Symbol(yytext[0]); return SYMBOL; }
\x8c { *yylval = Poincare::Symbol(yytext[0]); return SYMBOL; }
\x8f { *yylval = Poincare::Symbol(yytext[0]); return SYMBOL; }
\x90 { return STO; }
\x91 { *yylval = SquareRoot(); return FUNCTION; }
= { return EQUAL; }
\+ { return PLUS; }
\- { return MINUS; }
\x94 { return MULTIPLY; }
\x95 { return MULTIPLY; }
\* { return MULTIPLY; }
\/ { return DIVIDE; }
\^ { return POW; }
\! { return BANG; }
\( { return LEFT_PARENTHESIS; }
\) { return RIGHT_PARENTHESIS; }
\{ { return LEFT_BRACE; }
\} { return RIGHT_BRACE; }
\[ { return LEFT_BRACKET; }
\] { return RIGHT_BRACKET; }
\, { return COMMA; }
\_ { return UNDERSCORE; }
\x98 { *yylval = EmptyExpression(); return TERM; }
[ ]+ /* Ignore whitespaces */
. { return UNDEFINED_SYMBOL; }

%%
