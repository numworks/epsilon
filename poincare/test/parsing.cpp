#include <poincare/init.h>
#include <poincare/exception_checkpoint.h>
#include <poincare/src/parsing/parser.h>
#include <apps/shared/global_context.h>
#include "tree/helpers.h"
#include "helper.h"

using namespace Poincare;

void assert_tokenizes_as(const Token::Type * tokenTypes, const char * string) {
  Tokenizer tokenizer(string);
  while (true) {
    Token token = tokenizer.popToken();
    quiz_assert_print_if_failure(token.type() == *tokenTypes, string);
    if (token.type() == Token::EndOfStream) {
      return;
    }
    tokenTypes++;
  }
}

void assert_tokenizes_as_number(const char * string) {
  const Token::Type types[] = {Token::Number, Token::EndOfStream};
  assert_tokenizes_as(types, string);
}

void assert_tokenizes_as_unit(const char * string) {
  const Token::Type types[] = {Token::Unit, Token::EndOfStream};
  assert_tokenizes_as(types, string);
}

void assert_tokenizes_as_undefined_token(const char * string) {
  Tokenizer tokenizer(string);
  while (true) {
    Token token = tokenizer.popToken();
    if (token.type() == Token::Undefined) {
      return;
    }
    quiz_assert_print_if_failure(token.type() != Token::EndOfStream, string);
  }
}

void assert_text_not_parsable(const char * text) {
  Expression result = Expression::Parse(text, nullptr);
  quiz_assert_print_if_failure(result.isUninitialized(), text);
}

void assert_parsed_expression_is(const char * expression, Poincare::Expression r, bool addParentheses = false) {
  Shared::GlobalContext context;
  Expression e = parse_expression(expression, &context, addParentheses);
  quiz_assert_print_if_failure(e.isIdenticalTo(r), expression);
}

void assert_parsed_expression_with_user_parentheses_is(const char * expression, Poincare::Expression r) { return assert_parsed_expression_is(expression, r, true); }

QUIZ_CASE(poincare_parsing_tokenize_numbers) {
  assert_tokenizes_as_number("1");
  assert_tokenizes_as_number("12");
  assert_tokenizes_as_number("123");
  assert_tokenizes_as_number("1.3");
  assert_tokenizes_as_number(".3");
  assert_tokenizes_as_number("1.3·¥á3");
  assert_tokenizes_as_number("12.34·¥á56");
  assert_tokenizes_as_number(".3·¥á-32");
  assert_tokenizes_as_number("12.");
  assert_tokenizes_as_number(".999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999");
  assert_tokenizes_as_number("0.");
  assert_tokenizes_as_number("1.·¥á-4");
  assert_tokenizes_as_number("1.·¥á9999");

  const Token::Type binaryType[] = {Token::BinaryNumber, Token::EndOfStream};
  assert_tokenizes_as(binaryType, "0b0011010101");
  const Token::Type hexadecimalType[] = {Token::HexadecimalNumber, Token::EndOfStream};
  assert_tokenizes_as(hexadecimalType, "0x1234567890ABCDEF");

  assert_tokenizes_as_undefined_token("1·¥á");
  assert_tokenizes_as_undefined_token("1..");
  assert_tokenizes_as_undefined_token("..");
  assert_tokenizes_as_undefined_token("1.·¥á·¥á");
  assert_tokenizes_as_undefined_token("1.·¥á");
  assert_tokenizes_as_undefined_token("1·¥á--4");
  assert_tokenizes_as_undefined_token("1.·¥á·¥á4");
  assert_tokenizes_as_undefined_token("1·¥á2·¥á4");
  assert_tokenizes_as_undefined_token("0b2");
  assert_tokenizes_as_undefined_token("0xG");
}

QUIZ_CASE(poincare_parsing_memory_exhaustion) {
  int initialPoolSize = pool_size();
  assert_parsed_expression_is("2+3",Addition::Builder(BasedInteger::Builder(2), BasedInteger::Builder(3)));
  assert_pool_size(initialPoolSize);

  int memoryFailureHasBeenHandled = false;
  {
    Poincare::ExceptionCheckpoint ecp;
    if (ExceptionRun(ecp)) {
      Addition a = Addition::Builder();
      while (true) {
        Expression e = Expression::Parse("1+2+3+4+5+6+7+8+9+10", nullptr);
        a.addChildAtIndexInPlace(e, 0, a.numberOfChildren());
      }
    } else {
      Poincare::Tidy();
      memoryFailureHasBeenHandled = true;
    }
  }

  quiz_assert(memoryFailureHasBeenHandled);
  assert_pool_size(initialPoolSize);
  Expression e = Expression::Parse("1+1", nullptr);
  /* Stupid check to make sure the global variable generated by Bison is not
   * ruining everything */
}

QUIZ_CASE(poincare_parsing_parse_numbers) {
  // Parse decimal
  assert_parsed_expression_is("0", BasedInteger::Builder(0));
  assert_parsed_expression_is("0.1", Decimal::Builder(0.1));
  assert_parsed_expression_is("1.", BasedInteger::Builder(1));
  assert_parsed_expression_is(".1", Decimal::Builder(0.1));
  assert_parsed_expression_is("0·¥á2", Decimal::Builder(0.0));
  assert_parsed_expression_is("0.1·¥á2", Decimal::Builder(10.0));
  assert_parsed_expression_is("1.·¥á2", Decimal::Builder(100.0));
  assert_parsed_expression_is(".1·¥á2", Decimal::Builder(10.0));
  assert_parsed_expression_is("0·¥á-2", Decimal::Builder(0.0));
  assert_parsed_expression_is("0.1·¥á-2", Decimal::Builder(0.001));
  assert_parsed_expression_is("1.·¥á-2", Decimal::Builder(0.01));
  assert_parsed_expression_is(".1·¥á-2", Decimal::Builder(0.001));
  // Decimal with rounding when digits are above 14
  assert_parsed_expression_is("0.0000012345678901234", Decimal::Builder(Integer("12345678901234"), -6));
  assert_parsed_expression_is("0.00000123456789012345", Decimal::Builder(Integer("12345678901235"), -6));
  assert_parsed_expression_is("0.00000123456789012341", Decimal::Builder(Integer("12345678901234"), -6));
  assert_parsed_expression_is("1234567890123.4", Decimal::Builder(Integer("12345678901234"), 12));
  assert_parsed_expression_is("123456789012345.2", Decimal::Builder(Integer("12345678901235"), 14));
  assert_parsed_expression_is("123456789012341.2", Decimal::Builder(Integer("12345678901234"), 14));
  assert_parsed_expression_is("12.34567", Decimal::Builder(Integer("1234567"), 1));
  assert_parsed_expression_is(".999999999999990", Decimal::Builder(Integer("99999999999999"), -1));
  assert_parsed_expression_is("9.99999999999994", Decimal::Builder(Integer("99999999999999"), 0));
  assert_parsed_expression_is("99.9999999999995", Decimal::Builder(Integer("100000000000000"), 2));
  assert_parsed_expression_is("999.999999999999", Decimal::Builder(Integer("100000000000000"), 3));
  assert_parsed_expression_is("9999.99199999999", Decimal::Builder(Integer("99999920000000"), 3));
  assert_parsed_expression_is("99299.9999999999", Decimal::Builder(Integer("99300000000000"), 4));

  // Parse integer
  assert_parsed_expression_is("123456789012345678765434567", BasedInteger::Builder("123456789012345678765434567"));
  assert_parsed_expression_is(MaxIntegerString(), BasedInteger::Builder(MaxIntegerString()));

  // Parsed Based integer
  assert_parsed_expression_is("0b1011", BasedInteger::Builder("1011", 4, Integer::Base::Binary));
  assert_parsed_expression_is("0x12AC", BasedInteger::Builder("12AC", 4, Integer::Base::Hexadecimal));

  // Integer parsed in Decimal because they overflow Integer
  assert_parsed_expression_is(OverflowedIntegerString(), Decimal::Builder(Integer("17976931348623"), 308));
  assert_parsed_expression_is("179769313486235590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216", Decimal::Builder(Integer("17976931348624"), 308));

  // Infinity
  assert_parsed_expression_is("23·¥á1000", Infinity::Builder(false));
  assert_parsed_expression_is("2.3·¥á1000", Decimal::Builder(Integer(23), 1000));

  // Zero
  assert_parsed_expression_is("0.23·¥á-1000", Decimal::Builder(Integer(0), 0));
  assert_parsed_expression_is("0.23·¥á-999", Decimal::Builder(Integer(23), -1000));
}

QUIZ_CASE(poincare_parsing_parse) {
  assert_parsed_expression_is("1", BasedInteger::Builder(1));
  assert_parsed_expression_is("(1)", Parenthesis::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("((1))", Parenthesis::Builder((Expression)Parenthesis::Builder(BasedInteger::Builder(1))));
  assert_parsed_expression_is("1+2", Addition::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2)));
  assert_parsed_expression_is("(1)+2", Addition::Builder(Parenthesis::Builder(BasedInteger::Builder(1)),BasedInteger::Builder(2)));
  assert_parsed_expression_is("(1+2)", Parenthesis::Builder(Addition::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2))));
  Expression::Tuple one_two_three = {BasedInteger::Builder(1),BasedInteger::Builder(2),BasedInteger::Builder(3)};
  assert_parsed_expression_is("1+2+3", Addition::Builder(one_two_three));
  assert_parsed_expression_is("1+2+(3+4)", Addition::Builder({BasedInteger::Builder(1), BasedInteger::Builder(2), Parenthesis::Builder(Addition::Builder(BasedInteger::Builder(3),BasedInteger::Builder(4)))}));
  assert_parsed_expression_is("1√ó2", Multiplication::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2)));
  assert_parsed_expression_is("1√ó2√ó3", Multiplication::Builder(one_two_three));
  assert_parsed_expression_is("1+2√ó3", Addition::Builder(BasedInteger::Builder(1), Multiplication::Builder(BasedInteger::Builder(2), BasedInteger::Builder(3))));
  assert_parsed_expression_is("1/2", Division::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2)));
  assert_parsed_expression_is("(1/2)", Parenthesis::Builder(Division::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2))));
  assert_parsed_expression_is("1/2/3", Division::Builder(Division::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2)),BasedInteger::Builder(3)));
  assert_parsed_expression_is("1/2√ó3", Multiplication::Builder(Division::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2)),BasedInteger::Builder(3)));
  assert_parsed_expression_is("(1/2√ó3)", Parenthesis::Builder(Multiplication::Builder(Division::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2)),BasedInteger::Builder(3))));
  assert_parsed_expression_is("1√ó2/3", Multiplication::Builder(BasedInteger::Builder(1),Division::Builder(BasedInteger::Builder(2),BasedInteger::Builder(3))));
  assert_parsed_expression_is("(1√ó2/3)", Parenthesis::Builder(Multiplication::Builder(BasedInteger::Builder(1),Division::Builder(BasedInteger::Builder(2),BasedInteger::Builder(3)))));
  assert_parsed_expression_is("(1/2/3)", Parenthesis::Builder(Division::Builder(Division::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2)),BasedInteger::Builder(3))));
  assert_parsed_expression_is("1^2", Power::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2)));
  assert_parsed_expression_is("1^2^3", Power::Builder(BasedInteger::Builder(1),Power::Builder(BasedInteger::Builder(2),BasedInteger::Builder(3))));
  assert_parsed_expression_is("1=2", Equal::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2)));
  assert_text_not_parsable("=5");
  assert_text_not_parsable("1=2=3");
  assert_parsed_expression_is("-1", Opposite::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("(-1)", Parenthesis::Builder(Opposite::Builder(BasedInteger::Builder(1))));
  assert_parsed_expression_is("1-2", Subtraction::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2)));
  assert_parsed_expression_is("-1-2", Subtraction::Builder(Opposite::Builder(BasedInteger::Builder(1)),BasedInteger::Builder(2)));
  assert_parsed_expression_is("1-2-3", Subtraction::Builder(Subtraction::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2)),BasedInteger::Builder(3)));
  assert_parsed_expression_is("(1-2)", Parenthesis::Builder(Subtraction::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2))));
  assert_parsed_expression_is("1+-2", Addition::Builder(BasedInteger::Builder(1),Opposite::Builder(BasedInteger::Builder(2))));
  assert_parsed_expression_is("--1", Opposite::Builder((Expression)Opposite::Builder(BasedInteger::Builder(1))));
  assert_parsed_expression_is("(1+2)-3", Subtraction::Builder(Parenthesis::Builder(Addition::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2))),BasedInteger::Builder(3)));
  assert_parsed_expression_is("(2√ó-3)", Parenthesis::Builder(Multiplication::Builder(BasedInteger::Builder(2),Opposite::Builder(BasedInteger::Builder(3)))));
  assert_parsed_expression_is("1^(2)-3", Subtraction::Builder(Power::Builder(BasedInteger::Builder(1),Parenthesis::Builder(BasedInteger::Builder(2))),BasedInteger::Builder(3)));
  assert_parsed_expression_is("1^2-3", Subtraction::Builder(Power::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2)),BasedInteger::Builder(3)));
  assert_parsed_expression_is("2^-3", Power::Builder(BasedInteger::Builder(2),Opposite::Builder(BasedInteger::Builder(3))));
  assert_parsed_expression_is("2--2+-1", Addition::Builder(Subtraction::Builder(BasedInteger::Builder(2),Opposite::Builder(BasedInteger::Builder(2))),Opposite::Builder(BasedInteger::Builder(1))));
  assert_parsed_expression_is("2--2√ó-1", Subtraction::Builder(BasedInteger::Builder(2),Opposite::Builder(Multiplication::Builder(BasedInteger::Builder(2),Opposite::Builder(BasedInteger::Builder(1))))));
  assert_parsed_expression_is("-1^2", Opposite::Builder(Power::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2))));
  assert_parsed_expression_is("2‚ÑØ^(3)", Multiplication::Builder(BasedInteger::Builder(2),Power::Builder(Constant::Builder(UCodePointScriptSmallE),Parenthesis::Builder(BasedInteger::Builder(3)))));
  assert_parsed_expression_is("2/-3/-4", Division::Builder(Division::Builder(BasedInteger::Builder(2),Opposite::Builder(BasedInteger::Builder(3))),Opposite::Builder(BasedInteger::Builder(4))));
  assert_parsed_expression_is("1√ó2-3√ó4", Subtraction::Builder(Multiplication::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2)),Multiplication::Builder(BasedInteger::Builder(3),BasedInteger::Builder(4))));
  assert_parsed_expression_is("-1√ó2", Opposite::Builder(Multiplication::Builder(BasedInteger::Builder(1), BasedInteger::Builder(2))));
  assert_parsed_expression_is("1!", Factorial::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("1+2!", Addition::Builder(BasedInteger::Builder(1),Factorial::Builder(BasedInteger::Builder(2))));
  assert_parsed_expression_is("1!+2", Addition::Builder(Factorial::Builder(BasedInteger::Builder(1)),BasedInteger::Builder(2)));
  assert_parsed_expression_is("1!+2!", Addition::Builder(Factorial::Builder(BasedInteger::Builder(1)),Factorial::Builder(BasedInteger::Builder(2))));
  assert_parsed_expression_is("1√ó2!", Multiplication::Builder(BasedInteger::Builder(1),Factorial::Builder(BasedInteger::Builder(2))));
  assert_parsed_expression_is("1!√ó2", Multiplication::Builder(Factorial::Builder(BasedInteger::Builder(1)),BasedInteger::Builder(2)));
  assert_parsed_expression_is("1!√ó2!", Multiplication::Builder(Factorial::Builder(BasedInteger::Builder(1)),Factorial::Builder(BasedInteger::Builder(2))));
  assert_parsed_expression_is("1-2!", Subtraction::Builder(BasedInteger::Builder(1),Factorial::Builder(BasedInteger::Builder(2))));
  assert_parsed_expression_is("1!-2", Subtraction::Builder(Factorial::Builder(BasedInteger::Builder(1)),BasedInteger::Builder(2)));
  assert_parsed_expression_is("1!-2!", Subtraction::Builder(Factorial::Builder(BasedInteger::Builder(1)),Factorial::Builder(BasedInteger::Builder(2))));
  assert_parsed_expression_is("1/2!", Division::Builder(BasedInteger::Builder(1),Factorial::Builder(BasedInteger::Builder(2))));
  assert_parsed_expression_is("1!/2", Division::Builder(Factorial::Builder(BasedInteger::Builder(1)),BasedInteger::Builder(2)));
  assert_parsed_expression_is("1!/2!", Division::Builder(Factorial::Builder(BasedInteger::Builder(1)),Factorial::Builder(BasedInteger::Builder(2))));
  assert_parsed_expression_is("1^2!", Power::Builder(BasedInteger::Builder(1),Factorial::Builder(BasedInteger::Builder(2))));
  assert_parsed_expression_is("1!^2", Power::Builder(Factorial::Builder(BasedInteger::Builder(1)),BasedInteger::Builder(2)));
  assert_parsed_expression_is("1!^2!", Power::Builder(Factorial::Builder(BasedInteger::Builder(1)),Factorial::Builder(BasedInteger::Builder(2))));
  assert_parsed_expression_is("(1)!", Factorial::Builder(Parenthesis::Builder(BasedInteger::Builder(1))));
  assert_text_not_parsable("1+");
  assert_text_not_parsable(")");
  assert_text_not_parsable(")(");
  assert_text_not_parsable("()");
  assert_text_not_parsable("(1");
  assert_text_not_parsable("1)");
  assert_text_not_parsable("1++2");
  assert_text_not_parsable("1//2");
  assert_text_not_parsable("√ó1");
  assert_text_not_parsable("1^^2");
  assert_text_not_parsable("^1");
  assert_text_not_parsable("t0000000");
  assert_text_not_parsable("[[t0000000[");
  assert_text_not_parsable("0‚Üíx=0");
  assert_text_not_parsable("0=0‚Üíx");
  assert_text_not_parsable("1·¥á2·¥á3");
  assert_text_not_parsable("0b001112");
  assert_text_not_parsable("0x123G");
}

Matrix BuildMatrix(int rows, int columns, Expression entries[]) {
  Matrix m = Matrix::Builder();
  int position = 0;
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < columns; j++) {
      m.addChildAtIndexInPlace(entries[position], position, position);
      position++;
    }
  }
  m.setDimensions(rows, columns);
  return m;
}

QUIZ_CASE(poincare_parsing_matrices) {
  Expression m1[] = {BasedInteger::Builder(1)};
  assert_parsed_expression_is("[[1]]", BuildMatrix(1,1,m1));
  Expression m2[] = {BasedInteger::Builder(1),BasedInteger::Builder(2),BasedInteger::Builder(3)};
  assert_parsed_expression_is("[[1,2,3]]", BuildMatrix(1,3,m2));
  Expression m3[] = {BasedInteger::Builder(1),BasedInteger::Builder(2),BasedInteger::Builder(3),BasedInteger::Builder(4),BasedInteger::Builder(5),BasedInteger::Builder(6)};
  assert_parsed_expression_is("[[1,2,3][4,5,6]]", BuildMatrix(2,3,m3));
  Expression m4[] = {BasedInteger::Builder(1), BuildMatrix(1,1,m1)};
  assert_parsed_expression_is("[[1,[[1]]]]", BuildMatrix(1,2,m4));
  assert_text_not_parsable("[");
  assert_text_not_parsable("]");
  assert_text_not_parsable("[[");
  assert_text_not_parsable("][");
  assert_text_not_parsable("[]");
  assert_text_not_parsable("[1]");
  assert_text_not_parsable("[[1,2],[3]]");
  assert_text_not_parsable("[[]");
  assert_text_not_parsable("[[1]");
  assert_text_not_parsable("[1]]");
  assert_text_not_parsable("[[,]]");
  assert_text_not_parsable("[[1,]]");
  assert_text_not_parsable(",");
  assert_text_not_parsable("[,]");
}

QUIZ_CASE(poincare_parsing_units) {
  // Units
  for (const Unit::Dimension * dim = Unit::DimensionTable; dim < Unit::DimensionTableUpperBound; dim++) {
    for (const Unit::Representative * rep = dim->stdRepresentative(); rep < dim->representativesUpperBound(); rep++) {
      static constexpr size_t bufferSize = 10;
      char buffer[bufferSize];
      Unit::Builder(dim, rep, &Unit::EmptyPrefix).serialize(buffer, bufferSize, Preferences::PrintFloatMode::Decimal, Preferences::VeryShortNumberOfSignificantDigits);
      Expression unit = parse_expression(buffer, nullptr, false);
      quiz_assert_print_if_failure(unit.type() == ExpressionNode::Type::Unit, "Should be parsed as a Unit");
      if (rep->isPrefixable()) {
        for (const Unit::Prefix * pre = Unit::AllPrefixes; pre < Unit::AllPrefixes + sizeof(Unit::AllPrefixes)/sizeof(Unit::Prefix); pre++) {
          Unit::Builder(dim, rep, pre).serialize(buffer, bufferSize, Preferences::PrintFloatMode::Decimal, Preferences::VeryShortNumberOfSignificantDigits);
          Expression unit = parse_expression(buffer, nullptr, false);
          quiz_assert_print_if_failure(unit.type() == ExpressionNode::Type::Unit, "Should be parsed as a Unit");
        }
      }
    }
  }

  // Non-existing units are not parsable
  assert_text_not_parsable("_n");
  assert_text_not_parsable("_a");

  // Any identifier starting with '_' is tokenized as a unit
  assert_tokenizes_as_unit("_m");
  assert_tokenizes_as_unit("_A");

  // Can parse implicit multiplication with units
  Expression kilometer = Expression::Parse("_km", nullptr);
  Expression second = Expression::Parse("_s", nullptr);
  assert_parsed_expression_is("_kmœÄ", Multiplication::Builder(kilometer, Constant::Builder(UCodePointGreekSmallLetterPi)));
  assert_parsed_expression_is("œÄ_km", Multiplication::Builder(Constant::Builder(UCodePointGreekSmallLetterPi), kilometer));
  assert_parsed_expression_is("_s_km", Multiplication::Builder(second, kilometer));
  assert_parsed_expression_is("3_s", Multiplication::Builder(BasedInteger::Builder(3), second));
}

QUIZ_CASE(poincare_parsing_identifiers) {
  // User-defined symbols
  assert_parsed_expression_is("a", Symbol::Builder("a", 1));
  assert_parsed_expression_is("x", Symbol::Builder("x", 1));
  assert_parsed_expression_is("toot", Symbol::Builder("toot", 4));
  assert_parsed_expression_is("toto_", Symbol::Builder("toto_", 5));
  assert_parsed_expression_is("t_toto", Symbol::Builder("t_toto", 6));
  assert_parsed_expression_is("tot12", Symbol::Builder("tot12", 5));
  assert_parsed_expression_is("TOto", Symbol::Builder("TOto", 4));
  assert_parsed_expression_is("TO12_Or", Symbol::Builder("TO12_Or", 7));
  assert_parsed_expression_is("f(f)", Multiplication::Builder(Symbol::Builder("f", 1), Parenthesis::Builder(Symbol::Builder("f", 1))));
  assert_parsed_expression_is("f((1))", Multiplication::Builder(Symbol::Builder("f", 1), Parenthesis::Builder( Parenthesis::Builder(BasedInteger::Builder(1)))));
  assert_text_not_parsable("_a");
  assert_text_not_parsable("abcdefgh");
  assert_text_not_parsable("f(1,2)");

  // User-defined functions
  assert_parsed_expression_is("1‚Üíf(x)", Store::Builder(BasedInteger::Builder(1), Function::Builder("f", 1, Symbol::Builder("x",1))));
  assert_parsed_expression_is("1‚Üíab12AB_(x)", Store::Builder(BasedInteger::Builder(1), Function::Builder("ab12AB_", 7, Symbol::Builder("x",1))));

  // Reserved symbols
  assert_parsed_expression_is("ans", Symbol::Builder("ans", 3));
  assert_parsed_expression_is("ùê¢", Constant::Builder(UCodePointMathematicalBoldSmallI));
  assert_parsed_expression_is("œÄ", Constant::Builder(UCodePointGreekSmallLetterPi));
  assert_parsed_expression_is("‚ÑØ", Constant::Builder(UCodePointScriptSmallE));
  assert_parsed_expression_is(Infinity::Name(), Infinity::Builder(false));
  assert_parsed_expression_is(Undefined::Name(), Undefined::Builder());

  assert_text_not_parsable("u");
  assert_text_not_parsable("v");

  // Reserved functions
  assert_parsed_expression_is("acos(1)", ArcCosine::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("acosh(1)", HyperbolicArcCosine::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("abs(1)", AbsoluteValue::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("arg(1)", ComplexArgument::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("asin(1)", ArcSine::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("asinh(1)", HyperbolicArcSine::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("atan(1)", ArcTangent::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("atanh(1)", HyperbolicArcTangent::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("binomial(2,1)", BinomialCoefficient::Builder(BasedInteger::Builder(2),BasedInteger::Builder(1)));
  assert_parsed_expression_is("ceil(1)", Ceiling::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("confidence(1,2)", ConfidenceInterval::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2)));
  assert_text_not_parsable("diff(1,2,3)");
  assert_text_not_parsable("diff(0,_s,0)");
  assert_parsed_expression_is("diff(1,x,3)", Derivative::Builder(BasedInteger::Builder(1),Symbol::Builder("x",1),BasedInteger::Builder(3)));
  assert_parsed_expression_is("dim(1)", MatrixDimension::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("conj(1)", Conjugate::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("det(1)", Determinant::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("cos(1)", Cosine::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("cosh(1)", HyperbolicCosine::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("factor(1)", Factor::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("floor(1)", Floor::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("frac(1)", FracPart::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("gcd(1,2)", GreatCommonDivisor::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2)));
  assert_parsed_expression_is("im(1)", ImaginaryPart::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("int(1,x,2,3)", Integral::Builder(BasedInteger::Builder(1),Symbol::Builder("x",1),BasedInteger::Builder(2),BasedInteger::Builder(3)));
  assert_text_not_parsable("int(1,2,3,4)");
  assert_text_not_parsable("int(1,_s,3,4)");
  assert_parsed_expression_is("inverse(1)", MatrixInverse::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("lcm(1,2)", LeastCommonMultiple::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2)));
  assert_parsed_expression_is("ln(1)", NaperianLogarithm::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("log(1)", CommonLogarithm::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("log(1,2)", Logarithm::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2)));
  assert_parsed_expression_is("log{2}(1)", Logarithm::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2)));
  assert_parsed_expression_is("permute(2,1)", PermuteCoefficient::Builder(BasedInteger::Builder(2),BasedInteger::Builder(1)));
  assert_parsed_expression_is("prediction95(1,2)", PredictionInterval::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2)));
  assert_parsed_expression_is("prediction(1,2)", SimplePredictionInterval::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2)));
  assert_parsed_expression_is("product(1,n,2,3)", Product::Builder(BasedInteger::Builder(1),Symbol::Builder("n",1),BasedInteger::Builder(2),BasedInteger::Builder(3)));
  assert_text_not_parsable("product(1,2,3,4)");
  assert_text_not_parsable("product(1,_s,3,4)");
  assert_parsed_expression_is("quo(1,2)", DivisionQuotient::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2)));
  assert_parsed_expression_is("random()", Random::Builder());
  assert_parsed_expression_is("randint(1,2)", Randint::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2)));
  assert_parsed_expression_is("re(1)", RealPart::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("rem(1,2)", DivisionRemainder::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2)));
  assert_parsed_expression_is("root(1,2)", NthRoot::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2)));
  assert_parsed_expression_is("round(1,2)", Round::Builder(BasedInteger::Builder(1),BasedInteger::Builder(2)));
  assert_parsed_expression_is("sin(1)", Sine::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("sign(1)", SignFunction::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("sinh(1)", HyperbolicSine::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("sum(1,n,2,3)", Sum::Builder(BasedInteger::Builder(1),Symbol::Builder("n",1),BasedInteger::Builder(2),BasedInteger::Builder(3)));
  assert_text_not_parsable("sum(1,2,3,4)");
  assert_text_not_parsable("sum(1,_s,3,4)");
  assert_parsed_expression_is("tan(1)", Tangent::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("tanh(1)", HyperbolicTangent::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("trace(1)", MatrixTrace::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("transpose(1)", MatrixTranspose::Builder(BasedInteger::Builder(1)));
  assert_parsed_expression_is("‚àö(1)", SquareRoot::Builder(BasedInteger::Builder(1)));
  assert_text_not_parsable("cos(1,2)");
  assert_text_not_parsable("log(1,2,3)");
}

QUIZ_CASE(poincare_parsing_parse_store) {
  assert_parsed_expression_is("1‚Üía", Store::Builder(BasedInteger::Builder(1),Symbol::Builder("a",1)));
  assert_parsed_expression_is("1‚Üíe", Store::Builder(BasedInteger::Builder(1),Symbol::Builder("e",1)));
  assert_parsed_expression_is("1‚Üíf(x)", Store::Builder(BasedInteger::Builder(1),Function::Builder("f",1,Symbol::Builder("x",1))));
  assert_parsed_expression_is("x‚Üíf(x)", Store::Builder(Symbol::Builder("x",1),Function::Builder("f",1,Symbol::Builder("x",1))));
  assert_parsed_expression_is("n‚Üíf(x)", Store::Builder(Symbol::Builder("n",1),Function::Builder("f",1,Symbol::Builder("x",1))));
  Expression m0[] = {Symbol::Builder('x')};
  assert_parsed_expression_is("[[x]]‚Üíf(x)", Store::Builder(BuildMatrix(1,1,m0), Function::Builder("f", 1, Symbol::Builder('x'))));
  assert_text_not_parsable("a‚Üíb‚Üíc");
  assert_text_not_parsable("0‚Üí0‚Üíc");
  assert_text_not_parsable("1‚Üí");
  assert_text_not_parsable("‚Üí2");
  assert_text_not_parsable("(1‚Üía)");
  assert_text_not_parsable("1‚Üí\1"); // UnknownX
  assert_text_not_parsable("1‚Üí\2"); // UnknownN
  assert_text_not_parsable("1‚Üíacos");
  assert_text_not_parsable("1‚Üíf(2)");
  assert_text_not_parsable("1‚Üíf(f)");
  assert_text_not_parsable("3‚Üíf(g(4))");
}

QUIZ_CASE(poincare_parsing_parse_unit_convert) {
  Expression meter = Expression::Parse("_m", nullptr);
  assert_parsed_expression_is("1‚Üí_m", UnitConvert::Builder(BasedInteger::Builder(1), meter));
  Expression kilometer = Expression::Parse("_km", nullptr);
  assert_parsed_expression_is("1‚Üí_m/_km", UnitConvert::Builder(BasedInteger::Builder(1), Division::Builder(meter, kilometer)));

  assert_simplify("_m‚Üía", Radian, Real);
  assert_simplify("_m‚Üíb", Radian, Real);
  assert_text_not_parsable("1_km‚Üía√ób");

  assert_simplify("2‚Üía");
  assert_text_not_parsable("3_m‚Üía√ó_km");
  assert_simplify("2‚Üíf(x)");
  assert_text_not_parsable("3_m‚Üíf(2)√ó_km");

  // Clean the storage for other tests
  Ion::Storage::sharedStorage()->recordNamed("a.exp").destroy();
  Ion::Storage::sharedStorage()->recordNamed("b.exp").destroy();
  Ion::Storage::sharedStorage()->recordNamed("f.func").destroy();
}

QUIZ_CASE(poincare_parsing_implicit_multiplication) {
  assert_text_not_parsable(".1.2");
  assert_text_not_parsable("1 2");
  assert_parsed_expression_is("1x", Multiplication::Builder(BasedInteger::Builder(1),Symbol::Builder("x", 1)));
  assert_parsed_expression_is("1ans", Multiplication::Builder(BasedInteger::Builder(1),Symbol::Builder("ans", 3)));
  assert_parsed_expression_is("x1", Symbol::Builder("x1", 2));
  assert_parsed_expression_is("1x+2", Addition::Builder(Multiplication::Builder(BasedInteger::Builder(1),Symbol::Builder("x", 1)),BasedInteger::Builder(2)));
  assert_parsed_expression_is("1œÄ", Multiplication::Builder(BasedInteger::Builder(1),Constant::Builder(UCodePointGreekSmallLetterPi)));
  assert_parsed_expression_is("1x-2", Subtraction::Builder(Multiplication::Builder(BasedInteger::Builder(1),Symbol::Builder("x", 1)),BasedInteger::Builder(2)));
  assert_parsed_expression_is("-1x", Opposite::Builder(Multiplication::Builder(BasedInteger::Builder(1),Symbol::Builder("x", 1))));
  assert_parsed_expression_is("2√ó1x", Multiplication::Builder(BasedInteger::Builder(2),Multiplication::Builder(BasedInteger::Builder(1),Symbol::Builder("x", 1))));
  assert_parsed_expression_is("2^1x", Multiplication::Builder(Power::Builder(BasedInteger::Builder(2),BasedInteger::Builder(1)),Symbol::Builder("x", 1)));
  assert_parsed_expression_is("1x^2", Multiplication::Builder(BasedInteger::Builder(1),Power::Builder(Symbol::Builder("x", 1),BasedInteger::Builder(2))));
  assert_parsed_expression_is("2/1x", Division::Builder(BasedInteger::Builder(2),Multiplication::Builder(BasedInteger::Builder(1),Symbol::Builder("x", 1))));
  assert_parsed_expression_is("1x/2", Division::Builder(Multiplication::Builder(BasedInteger::Builder(1),Symbol::Builder("x", 1)),BasedInteger::Builder(2)));
  assert_parsed_expression_is("(1)2", Multiplication::Builder(Parenthesis::Builder(BasedInteger::Builder(1)),BasedInteger::Builder(2)));
  assert_parsed_expression_is("1(2)", Multiplication::Builder(BasedInteger::Builder(1),Parenthesis::Builder(BasedInteger::Builder(2))));
  assert_parsed_expression_is("sin(1)2", Multiplication::Builder(Sine::Builder(BasedInteger::Builder(1)),BasedInteger::Builder(2)));
  assert_parsed_expression_is("1cos(2)", Multiplication::Builder(BasedInteger::Builder(1),Cosine::Builder(BasedInteger::Builder(2))));
  assert_parsed_expression_is("1!2", Multiplication::Builder(Factorial::Builder(BasedInteger::Builder(1)),BasedInteger::Builder(2)));
  assert_parsed_expression_is("2‚ÑØ^(3)", Multiplication::Builder(BasedInteger::Builder(2),Power::Builder(Constant::Builder(UCodePointScriptSmallE),Parenthesis::Builder(BasedInteger::Builder(3)))));
  assert_parsed_expression_is("\u00122^3\u00133", Multiplication::Builder(Power::Builder(BasedInteger::Builder(2),BasedInteger::Builder(3)), BasedInteger::Builder(3)));
  Expression m1[] = {BasedInteger::Builder(1)}; Matrix M1 = BuildMatrix(1,1,m1);
  Expression m2[] = {BasedInteger::Builder(2)}; Matrix M2 = BuildMatrix(1,1,m2);
  assert_parsed_expression_is("[[1]][[2]]", Multiplication::Builder(M1,M2));
}

QUIZ_CASE(poincare_parsing_adding_missing_parentheses) {
  assert_parsed_expression_with_user_parentheses_is("1+-2", Addition::Builder(BasedInteger::Builder(1),Parenthesis::Builder(Opposite::Builder(BasedInteger::Builder(2)))));
  assert_parsed_expression_with_user_parentheses_is("1--2", Subtraction::Builder(BasedInteger::Builder(1),Parenthesis::Builder(Opposite::Builder(BasedInteger::Builder(2)))));
  assert_parsed_expression_with_user_parentheses_is("1+conj(-2)", Addition::Builder(BasedInteger::Builder(1),Parenthesis::Builder(Conjugate::Builder(Opposite::Builder(BasedInteger::Builder(2))))));
  assert_parsed_expression_with_user_parentheses_is("1-conj(-2)", Subtraction::Builder(BasedInteger::Builder(1),Parenthesis::Builder(Conjugate::Builder(Opposite::Builder(BasedInteger::Builder(2))))));
  assert_parsed_expression_with_user_parentheses_is("3conj(1+ùê¢)", Multiplication::Builder(BasedInteger::Builder(3), Parenthesis::Builder(Conjugate::Builder(Addition::Builder(BasedInteger::Builder(1), Constant::Builder(UCodePointMathematicalBoldSmallI))))));
  assert_parsed_expression_with_user_parentheses_is("2√ó-3", Multiplication::Builder(BasedInteger::Builder(2), Parenthesis::Builder(Opposite::Builder(BasedInteger::Builder(3)))));
  assert_parsed_expression_with_user_parentheses_is("2√ó-3", Multiplication::Builder(BasedInteger::Builder(2), Parenthesis::Builder(Opposite::Builder(BasedInteger::Builder(3)))));
  assert_parsed_expression_with_user_parentheses_is("--2", Opposite::Builder(Parenthesis::Builder(Opposite::Builder(BasedInteger::Builder(2)))));
  assert_parsed_expression_with_user_parentheses_is("\u00122/3\u0013^2", Power::Builder(Parenthesis::Builder(Division::Builder(BasedInteger::Builder(2), BasedInteger::Builder(3))), BasedInteger::Builder(2)));
  assert_parsed_expression_with_user_parentheses_is("log(1+-2)", CommonLogarithm::Builder(Addition::Builder(BasedInteger::Builder(1),Parenthesis::Builder(Opposite::Builder(BasedInteger::Builder(2))))));

  // Conjugate expressions
  assert_parsed_expression_with_user_parentheses_is("conj(-3)+2", Addition::Builder(Conjugate::Builder(Opposite::Builder(BasedInteger::Builder(3))), BasedInteger::Builder(2)));
  assert_parsed_expression_with_user_parentheses_is("2+conj(-3)", Addition::Builder(BasedInteger::Builder(2), Parenthesis::Builder(Conjugate::Builder(Opposite::Builder(BasedInteger::Builder(3))))));
  assert_parsed_expression_with_user_parentheses_is("conj(-3)√ó2", Multiplication::Builder(Conjugate::Builder(Opposite::Builder(BasedInteger::Builder(3))), BasedInteger::Builder(2)));
  assert_parsed_expression_with_user_parentheses_is("2√óconj(-3)", Multiplication::Builder(BasedInteger::Builder(2), Parenthesis::Builder(Conjugate::Builder(Opposite::Builder(BasedInteger::Builder(3))))));
  assert_parsed_expression_with_user_parentheses_is("conj(-3)-2", Subtraction::Builder(Conjugate::Builder(Opposite::Builder(BasedInteger::Builder(3))), BasedInteger::Builder(2)));
  assert_parsed_expression_with_user_parentheses_is("2-conj(-3)", Subtraction::Builder(BasedInteger::Builder(2), Parenthesis::Builder(Conjugate::Builder(Opposite::Builder(BasedInteger::Builder(3))))));
  assert_parsed_expression_with_user_parentheses_is("conj(2+3)^2", Power::Builder(Parenthesis::Builder(Conjugate::Builder(Addition::Builder(BasedInteger::Builder(2), BasedInteger::Builder(3)))), BasedInteger::Builder(2)));
  assert_parsed_expression_with_user_parentheses_is("-conj(2+3)", Opposite::Builder(Parenthesis::Builder(Conjugate::Builder(Addition::Builder(BasedInteger::Builder(2), BasedInteger::Builder(3))))));
  assert_parsed_expression_with_user_parentheses_is("conj(2+3)!", Factorial::Builder(Parenthesis::Builder(Conjugate::Builder(Addition::Builder(BasedInteger::Builder(2), BasedInteger::Builder(3))))));
}
